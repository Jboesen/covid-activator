This project is implemented on Flask. The website has essentially one function, which is to activate COVID tests. 

To do this, I had to store Color login information because otherwise, the app would be less convenient than simply using Color, and so would defeat the whole point. Of course, storing passwords is tricky business, so I decided to encrypt the password. At first, I was going to do this in the SQL database, itself, but I quickly realized that that would not work, so I instead opted to encrypt it on the server and pass the relevant information where it needed to go: pass the key to the client machine and pass the encrypted password into the database. I used cryptography and a Fernet key because they were the most widely-documented ways of server-side encryption. I decided to use a cookie to store the key because it seemed like it would be the most convenient and discreet mechanism: the user gains access to that key without even knowing it. Manually notating the key like a password would not necessarily work, either, because the keys are very long strings of random characters. Also, having an actual password gives the app an added layer of security.  

As a temporary solution, I added an account deletion page in case a user forgets their password. 

Once I had done that, I had to get the string of login information. I decided to use text recognition, simply because it is a pain to input 15 random numbers into the boxes. To do this, I used Tesseract, which is an open-source library supported by Google's photo-recognition software. That meant that it would probably be more accurate. However, I soon found out that this library did not like .heic's, so I had to convert the files. I did this using another open-source library, pyheif, and reading the image.

I also decided to put these more under-the-hood type functions in a separate python file simply because I decided that would make the app.py more navigable. 

After the photo was recognized, I sent the text back to a modified version of manual.html to avoid repetitively coding another page (or popup box) with text input and a confirm button. In case of errors, I decided to use flash() because 1) I found the redirecting to a separate page with the mad cat in Finance to be particularly annoying and inconvenient, and 2) flash() was a very convenient integrated way to display errors. 

Finally, I sent the text to Selenium. I decided to use Selenium because it is the most widely-supported web automation library for Python. To get that working on Heroku, I used two buildpacks: https://github.com/heroku/heroku-buildpack-google-chrome and https://github.com/heroku/heroku-buildpack-chromedriver. I did not include those files in this code because it would mess up the execution on Heroku, which is the ultimate purpose of this website. The execution of the Selenium is pretty basic, but I just used find_element_by_xpath() because most of Color's elements did not have name or id attributes. I also used try/except statements because without them, I found Selenium would try to access the element before it had loaded, and, in doing so, break the whole program and not successfully activate the test. 

